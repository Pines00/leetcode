### 题目
[原题地址]（https://leetcode-cn.com/problems/plus-one/）
给定一个非负整数组成的非空数组，在该数的基础上加一，返回一个新的数组。

最高位数字存放在数组的首位， 数组中每个元素只存储一个数字。

你可以假设除了整数 0 之外，这个整数不会以零开头
### 示例
  输入：[1,2,3]
   输出：[1,2,4]
 
 ## 思路 
  这题大概就是让做例如数字158加上1，但是在数组中进行，不能直接相加。例如出现这种数字159，加上1，会进行进位。
  如果直接相加就会错误。
  
  直接进行迭代 从最后一位数开始，例如159  ，从9开始，9+1=10，那么此时就要进位，进位的数字就为10/10=1，此时
  向十位进一位，那么剩下来得数字就为10%10=0.这样迭代到最后一位就可以完成相加
 举一个比较极端的例子：[9,9,9],加一之后就应该是[]1,0,0,0]
 下面按步骤分解
 * 1.从末尾9开始，9+1=10,10/10=1，进一位，10%10=0，此时最后一位应该进一位余0，最后结果就是0
 * 2.从末尾往前遍历，第二位也是9，那么9加上末尾进一位上来的1也为10，此时应该同时进行整除10进位，然后取余10位余数，进1余0，第二位也是0
 * 3.从末尾往前遍历，第三位也是9，同样加一为10，进行进一位余0。
 * 4.第三位为0，进了一位，进了一位也应该加入数组，因为999+1=1000，数组元素应该为4位，这是只需要迭代结束后，将进位的1插入到数组的首位即可
 * 就完成了这题。
关键设置carry位，用来记录进位。
```
class Solution {
public:
    vector<int> plusOne(vector<int>& digits) {
        int n =digits.size();
        int c = 1;//进位为1
        for(int i=n;i>0;i--){//从末尾开始遍历
            digits[i-1] = digits[i-1]+c;//每次遍历的数加上进位
            c=digits[i-1]/10;// 下一次进位的数
            digits[i-1]=digits[i-1]%10;//余数
        }
        if(c>0)digits.insert(digits.begin(),1);//判断一下遍历结束是否有进位如果有就插入到数字的首部
        return digits;
    }
};
```
